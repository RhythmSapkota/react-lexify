"use strict";const E=require("./graph-L5sQI78Q.js"),B=require("./layout-ChCyWgcE.js"),P=require("./clone-DlJxeEDR.js"),u=require("./edges-e0da2a9e-DUrf9DHT.js"),i=require("./index-CvlpYZ1D.js"),k=require("./createText-2e5e7dd3-BIMLrNIs.js");function v(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:G(e),edges:F(e)};return E.isUndefined(e.graph())||(t.value=P.clone(e.graph())),t}function G(e){return B.map(e.nodes(),function(t){var n=e.node(t),r=e.parent(t),s={v:t};return E.isUndefined(n)||(s.value=n),E.isUndefined(r)||(s.parent=r),s})}function F(e){return B.map(e.edges(),function(t){var n=e.edge(t),r={v:t.v,w:t.w};return E.isUndefined(t.name)||(r.name=t.name),E.isUndefined(n)||(r.value=n),r})}let a={},w={},T={};const M=()=>{w={},T={},a={}},X=(e,t)=>(i.log$1.trace("In isDescendant",t," ",e," = ",w[t].includes(e)),!!w[t].includes(e)),q=(e,t)=>(i.log$1.info("Descendants of ",t," is ",w[t]),i.log$1.info("Edge is ",e),e.v===t||e.w===t?!1:w[t]?w[t].includes(e.v)||X(e.v,t)||X(e.w,t)||w[t].includes(e.w):(i.log$1.debug("Tilt, ",t,",not in descendants"),!1)),D=(e,t,n,r)=>{i.log$1.warn("Copying children of ",e,"root",r,"data",t.node(e),r);const s=t.children(e)||[];e!==r&&s.push(e),i.log$1.warn("Copying (nodes) clusterId",e,"nodes",s),s.forEach(o=>{if(t.children(o).length>0)D(o,t,n,r);else{const f=t.node(o);i.log$1.info("cp ",o," to ",r," with parent ",e),n.setNode(o,f),r!==t.parent(o)&&(i.log$1.warn("Setting parent",o,t.parent(o)),n.setParent(o,t.parent(o))),e!==r&&o!==e?(i.log$1.debug("Setting parent",o,e),n.setParent(o,e)):(i.log$1.info("In copy ",e,"root",r,"data",t.node(e),r),i.log$1.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==r,"node!==clusterId",o!==e));const g=t.edges(o);i.log$1.debug("Copying Edges",g),g.forEach(d=>{i.log$1.info("Edge",d);const h=t.edge(d.v,d.w,d.name);i.log$1.info("Edge data",h,r);try{q(d,r)?(i.log$1.info("Copying as ",d.v,d.w,h,d.name),n.setEdge(d.v,d.w,h,d.name),i.log$1.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):i.log$1.info("Skipping copy of edge ",d.v,"-->",d.w," rootId: ",r," clusterId:",e)}catch($){i.log$1.error($)}})}i.log$1.debug("Removing node",o),t.removeNode(o)})},p=(e,t)=>{const n=t.children(e);let r=[...n];for(const s of n)T[s]=e,r=[...r,...p(s,t)];return r},C=(e,t)=>{i.log$1.trace("Searching",e);const n=t.children(e);if(i.log$1.trace("Searching children of id ",e,n),n.length<1)return i.log$1.trace("This is a valid node",e),e;for(const r of n){const s=C(r,t);if(s)return i.log$1.trace("Found replacement for",e," => ",s),s}},S=e=>!a[e]||!a[e].externalConnections?e:a[e]?a[e].id:e,j=(e,t)=>{if(!e||t>10){i.log$1.debug("Opting out, no graph ");return}else i.log$1.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(i.log$1.warn("Cluster identified",n," Replacement id in edges: ",C(n,e)),w[n]=p(n,e),a[n]={id:C(n,e),clusterData:e.node(n)})}),e.nodes().forEach(function(n){const r=e.children(n),s=e.edges();r.length>0?(i.log$1.debug("Cluster identified",n,w),s.forEach(o=>{if(o.v!==n&&o.w!==n){const f=X(o.v,n),g=X(o.w,n);f^g&&(i.log$1.warn("Edge: ",o," leaves cluster ",n),i.log$1.warn("Descendants of XXX ",n,": ",w[n]),a[n].externalConnections=!0)}})):i.log$1.debug("Not a cluster ",n,w)});for(let n of Object.keys(a)){const r=a[n].id,s=e.parent(r);s!==n&&a[s]&&!a[s].externalConnections&&(a[n].id=s)}e.edges().forEach(function(n){const r=e.edge(n);i.log$1.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),i.log$1.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let s=n.v,o=n.w;if(i.log$1.warn("Fix XXX",a,"ids:",n.v,n.w,"Translating: ",a[n.v]," --- ",a[n.w]),a[n.v]&&a[n.w]&&a[n.v]===a[n.w]){i.log$1.warn("Fixing and trixing link to self - removing XXX",n.v,n.w,n.name),i.log$1.warn("Fixing and trixing - removing XXX",n.v,n.w,n.name),s=S(n.v),o=S(n.w),e.removeEdge(n.v,n.w,n.name);const f=n.w+"---"+n.v;e.setNode(f,{domId:f,id:f,labelStyle:"",labelText:r.label,padding:0,shape:"labelRect",style:""});const g=structuredClone(r),d=structuredClone(r);g.label="",g.arrowTypeEnd="none",d.label="",g.fromCluster=n.v,d.toCluster=n.v,e.setEdge(s,f,g,n.name+"-cyclic-special"),e.setEdge(f,o,d,n.name+"-cyclic-special")}else if(a[n.v]||a[n.w]){if(i.log$1.warn("Fixing and trixing - removing XXX",n.v,n.w,n.name),s=S(n.v),o=S(n.w),e.removeEdge(n.v,n.w,n.name),s!==n.v){const f=e.parent(s);a[f].externalConnections=!0,r.fromCluster=n.v}if(o!==n.w){const f=e.parent(o);a[f].externalConnections=!0,r.toCluster=n.w}i.log$1.warn("Fix Replacing with XXX",s,o,n.name),e.setEdge(s,o,r,n.name)}}),i.log$1.warn("Adjusted Graph",v(e)),O(e,0),i.log$1.trace(a)},O=(e,t)=>{if(i.log$1.warn("extractor - ",t,v(e),e.children("D")),t>10){i.log$1.error("Bailing out");return}let n=e.nodes(),r=!1;for(const s of n){const o=e.children(s);r=r||o.length>0}if(!r){i.log$1.debug("Done, no node has children",e.nodes());return}i.log$1.debug("Nodes = ",n,t);for(const s of n)if(i.log$1.debug("Extracting node",s,a,a[s]&&!a[s].externalConnections,!e.parent(s),e.node(s),e.children("D")," Depth ",t),!a[s])i.log$1.debug("Not a cluster",s,t);else if(!a[s].externalConnections&&e.children(s)&&e.children(s).length>0){i.log$1.warn("Cluster without external connections, without a parent and with children",s,t);let f=e.graph().rankdir==="TB"?"LR":"TB";a[s]&&a[s].clusterData&&a[s].clusterData.dir&&(f=a[s].clusterData.dir,i.log$1.warn("Fixing dir",a[s].clusterData.dir,f));const g=new E.Graph({multigraph:!0,compound:!0}).setGraph({rankdir:f,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.log$1.warn("Old graph before copy",v(e)),D(s,e,g,s),e.setNode(s,{clusterNode:!0,id:s,clusterData:a[s].clusterData,labelText:a[s].labelText,graph:g}),i.log$1.warn("New graph after copy node: (",s,")",v(g)),i.log$1.debug("Old graph after copy",v(e))}else i.log$1.warn("Cluster ** ",s," **not meeting the criteria !externalConnections:",!a[s].externalConnections," no parent: ",!e.parent(s)," children ",e.children(s)&&e.children(s).length>0,e.children("D"),t),i.log$1.debug(a);n=e.nodes(),i.log$1.warn("New list of nodes",n);for(const s of n){const o=e.node(s);i.log$1.warn(" Now next level",s,o),o.clusterNode&&O(o.graph,t+1)}},R=(e,t)=>{if(t.length===0)return[];let n=Object.assign(t);return t.forEach(r=>{const s=e.children(r),o=R(e,s);n=[...n,...o]}),n},U=e=>R(e,e.children()),A=(e,t)=>{i.log$1.info("Creating subgraph rect for ",t.id,t);const n=i.getConfig(),r=e.insert("g").attr("class","cluster"+(t.class?" "+t.class:"")).attr("id",t.id),s=r.insert("rect",":first-child"),o=i.evaluate(n.flowchart.htmlLabels),f=r.insert("g").attr("class","cluster-label"),g=t.labelType==="markdown"?k.createText(f,t.labelText,{style:t.labelStyle,useHtmlLabels:o}):f.node().appendChild(u.createLabel$1(t.labelText,t.labelStyle,void 0,!0));let d=g.getBBox();if(i.evaluate(n.flowchart.htmlLabels)){const l=g.children[0],c=i.select(g);d=l.getBoundingClientRect(),c.attr("width",d.width),c.attr("height",d.height)}const h=0*t.padding,$=h/2,x=t.width<=d.width+h?d.width+h:t.width;t.width<=d.width+h?t.diff=(d.width-t.width)/2-t.padding/2:t.diff=-t.padding/2,i.log$1.trace("Data ",t,JSON.stringify(t)),s.attr("style",t.style).attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-x/2).attr("y",t.y-t.height/2-$).attr("width",x).attr("height",t.height+h);const{subGraphTitleTopMargin:m}=u.getSubGraphTitleMargins(n);o?f.attr("transform",`translate(${t.x-d.width/2}, ${t.y-t.height/2+m})`):f.attr("transform",`translate(${t.x}, ${t.y-t.height/2+m})`);const y=s.node().getBBox();return t.width=y.width,t.height=y.height,t.intersect=function(l){return u.intersectRect$1(t,l)},r},H=(e,t)=>{const n=e.insert("g").attr("class","note-cluster").attr("id",t.id),r=n.insert("rect",":first-child"),s=0*t.padding,o=s/2;r.attr("rx",t.rx).attr("ry",t.ry).attr("x",t.x-t.width/2-o).attr("y",t.y-t.height/2-o).attr("width",t.width+s).attr("height",t.height+s).attr("fill","none");const f=r.node().getBBox();return t.width=f.width,t.height=f.height,t.intersect=function(g){return u.intersectRect$1(t,g)},n},V=(e,t)=>{const n=i.getConfig(),r=e.insert("g").attr("class",t.classes).attr("id",t.id),s=r.insert("rect",":first-child"),o=r.insert("g").attr("class","cluster-label"),f=r.append("rect"),g=o.node().appendChild(u.createLabel$1(t.labelText,t.labelStyle,void 0,!0));let d=g.getBBox();if(i.evaluate(n.flowchart.htmlLabels)){const l=g.children[0],c=i.select(g);d=l.getBoundingClientRect(),c.attr("width",d.width),c.attr("height",d.height)}d=g.getBBox();const h=0*t.padding,$=h/2,x=t.width<=d.width+t.padding?d.width+t.padding:t.width;t.width<=d.width+t.padding?t.diff=(d.width+t.padding*0-t.width)/2:t.diff=-t.padding/2,s.attr("class","outer").attr("x",t.x-x/2-$).attr("y",t.y-t.height/2-$).attr("width",x+h).attr("height",t.height+h),f.attr("class","inner").attr("x",t.x-x/2-$).attr("y",t.y-t.height/2-$+d.height-1).attr("width",x+h).attr("height",t.height+h-d.height-3);const{subGraphTitleTopMargin:m}=u.getSubGraphTitleMargins(n);o.attr("transform",`translate(${t.x-d.width/2}, ${t.y-t.height/2-t.padding/3+(i.evaluate(n.flowchart.htmlLabels)?5:3)+m})`);const y=s.node().getBBox();return t.height=y.height,t.intersect=function(l){return u.intersectRect$1(t,l)},r},W=(e,t)=>{const n=e.insert("g").attr("class",t.classes).attr("id",t.id),r=n.insert("rect",":first-child"),s=0*t.padding,o=s/2;r.attr("class","divider").attr("x",t.x-t.width/2-o).attr("y",t.y-t.height/2).attr("width",t.width+s).attr("height",t.height+s);const f=r.node().getBBox();return t.width=f.width,t.height=f.height,t.diff=-t.padding/2,t.intersect=function(g){return u.intersectRect$1(t,g)},n},_={rect:A,roundedWithTitle:V,noteGroup:H,divider:W};let L={};const z=(e,t)=>{i.log$1.trace("Inserting cluster");const n=t.shape||"rect";L[t.id]=_[n](e,t)},K=()=>{L={}},J=async(e,t,n,r,s,o)=>{i.log$1.info("Graph in recursive render: XXX",v(t),s);const f=t.graph().rankdir;i.log$1.trace("Dir in recursive render - dir:",f);const g=e.insert("g").attr("class","root");t.nodes()?i.log$1.info("Recursive render XXX",t.nodes()):i.log$1.info("No nodes found for",t),t.edges().length>0&&i.log$1.trace("Recursive edges",t.edge(t.edges()[0]));const d=g.insert("g").attr("class","clusters"),h=g.insert("g").attr("class","edgePaths"),$=g.insert("g").attr("class","edgeLabels"),x=g.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(l){const c=t.node(l);if(s!==void 0){const b=JSON.parse(JSON.stringify(s.clusterData));i.log$1.info("Setting data for cluster XXX (",l,") ",b,s),t.setNode(s.id,b),t.parent(l)||(i.log$1.trace("Setting parent",l,s.id),t.setParent(l,s.id,b))}if(i.log$1.info("(Insert) Node XXX"+l+": "+JSON.stringify(t.node(l))),c&&c.clusterNode){i.log$1.info("Cluster identified",l,c.width,t.node(l));const b=await J(x,c.graph,n,r,t.node(l),o),N=b.elem;u.updateNodeBounds(c,N),c.diff=b.diff||0,i.log$1.info("Node bounds (abc123)",l,c,c.width,c.x,c.y),u.setNodeElem(N,c),i.log$1.warn("Recursive render complete ",N,c)}else t.children(l).length>0?(i.log$1.info("Cluster - the non recursive path XXX",l,c.id,c,t),i.log$1.info(C(c.id,t)),a[c.id]={id:C(c.id,t),node:c}):(i.log$1.info("Node - the non recursive path",l,c.id,c),await u.insertNode(x,t.node(l),f))})),t.edges().forEach(function(l){const c=t.edge(l.v,l.w,l.name);i.log$1.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(l)),i.log$1.info("Edge "+l.v+" -> "+l.w+": ",l," ",JSON.stringify(t.edge(l))),i.log$1.info("Fix",a,"ids:",l.v,l.w,"Translating: ",a[l.v],a[l.w]),u.insertEdgeLabel($,c)}),t.edges().forEach(function(l){i.log$1.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(l))}),i.log$1.info("#############################################"),i.log$1.info("###                Layout                 ###"),i.log$1.info("#############################################"),i.log$1.info(t),B.layout(t),i.log$1.info("Graph after layout:",v(t));let m=0;const{subGraphTitleTotalMargin:y}=u.getSubGraphTitleMargins(o);return U(t).forEach(function(l){const c=t.node(l);i.log$1.info("Position "+l+": "+JSON.stringify(t.node(l))),i.log$1.info("Position "+l+": ("+c.x,","+c.y,") width: ",c.width," height: ",c.height),c&&c.clusterNode?(c.y+=y,u.positionNode(c)):t.children(l).length>0?(c.height+=y,z(d,c),a[c.id].node=c):(c.y+=y/2,u.positionNode(c))}),t.edges().forEach(function(l){const c=t.edge(l);i.log$1.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(c),c),c.points.forEach(N=>N.y+=y/2);const b=u.insertEdge(h,l,c,a,n,t,r);u.positionEdgeLabel(c,b)}),t.nodes().forEach(function(l){const c=t.node(l);i.log$1.info(l,c.type,c.diff),c.type==="group"&&(m=c.diff)}),{elem:g,diff:m}},Q=async(e,t,n,r,s)=>{u.insertMarkers$1(e,n,r,s),u.clear$1(),u.clear(),K(),M(),i.log$1.warn("Graph at first:",JSON.stringify(v(t))),j(t),i.log$1.warn("Graph after:",JSON.stringify(v(t)));const o=i.getConfig();await J(e,t,r,s,void 0,o)};exports.render=Q;
//# sourceMappingURL=index-3862675e-Dx_IPd9f.js.map
